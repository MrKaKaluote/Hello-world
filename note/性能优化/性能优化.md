

### 一、webpack

1. 配置externals，引用cdn库
2. happyPack，将loader由单进程转为多进程
3. treeShaking
4. 按需加载组件

5. webpack开启Gzip

### 二、图片

1. 雪碧图

2. jpg/jpeg：**有损压缩、体积小、加载快、不支持透明**。适用于色彩丰富的图片（大图，比如banner......）

3. png-8和png-24：**无损压缩、质量高、体积大、支持透明**

   1)png-8：8 位的 PNG 最多支持 256 种颜色 

   2)png-24：而 24 位的可以呈现约 1600 万种颜色

4. svg：**文本文件、体积小、不失真、兼容性好**

5. Base64: **文本文件、依赖编码、小图标解决方案**

### 三、浏览器缓存机制

浏览器缓存优先级：memory cache、service worker cache、http cache、push cache

## HTTP 缓存

定义：http缓存分为**强混存**和**协商缓存**，强缓存优先级高，在命中强缓存失败的情况下，才会走协商缓存

##### 1.强缓存

expires： 允许我们通过**绝对的时间戳**来控制缓存过期时间，如果客户端和服务器端的时间不一致，会导致出错

Cache-Control:max-age：max-age 不是一个时间戳，而是一个相对时间长度，这就意味着它有能力规避掉 expires 可能会带来的时差问题；max-age 机制下，资源的过期判定不再受服务器时间戳的限制。客户端会记录请求到资源的时间点，以此作为相对时间的起点，从而确保参与计算的两个时间节点（起始时间和当前时间）都来源于客户端，由此便能够实现更加精准的判断。

s-maxage，取代理服务器的缓存

no-cache，绕开强缓存，走协商缓存

no-store，什么缓存都不走，取服务器拉取资源

**Cache-Control 的 max-age 配置项相对于 expires 的优先级更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准**

##### 2. 协商缓存：浏览器与服务器合作之下的缓存策略

注：*协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源*，**返回状态码为304，重定向到浏览器缓存**

**1）Last-modified**

用于标记服务端文件的时间戳，首次response会携带Last-modified，再次请求request携带If-Modified-Since，两次结果一样走协商缓存，弊端如下：

![image-20210331130119658](/Users/gaosong/Library/Application Support/typora-user-images/image-20210331130119658.png)

**2）Etag**

用于表示服务端文件的标示，首次response携带Etag，再次请求request携带If-None-Match，两次结果一样走缓存，否则走请求

![image-20210331130442488](/Users/gaosong/Library/Application Support/typora-user-images/image-20210331130442488.png)

## MemoryCache

MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。

内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。

那么哪些文件会被放入内存呢？

事实上，这个划分规则，一直以来是没有定论的。不过想想也可以理解，内存是有限的，很多时候需要先考虑即时呈现的内存余量，再根据具体的情况决定分配给内存和磁盘的资源量的比重——资源存放的位置具有一定的随机性。

虽然划分规则没有定论，但根据日常开发中观察的结果，包括我们开篇给大家展示的 Network 截图，我们至少可以总结出这样的规律：资源存不存内存，浏览器秉承的是“节约原则”。我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”；此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。

